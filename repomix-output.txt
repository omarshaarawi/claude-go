This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-10T04:35:52.606Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
claude/
  internal/
    errors/
      factory.go
      response.go
      types.go
    models/
      models.go
    ratelimit/
      limiter.go
    transport/
      retry.go
      sse.go
  client.go
  config.go
  conversation.go
  errors.go
  message_batches.go
  messages.go
  models.go
  options.go
  version.go
examples/
  main.go
.gitignore
go.mod
go.sum
LICENSE
README.md

================================================================
Repository Files
================================================================

================
File: claude/internal/errors/factory.go
================
package errors

import (
	"fmt"
	"net/http"
)

// NewAPIError creates a new APIError from error details
func NewAPIError(errorType ErrorType, message string) *APIError {
	return &APIError{
		Type: string(errorType),
		ErrorDetails: struct {
			Type    string `json:"type"`
			Message string `json:"message"`
		}{
			Type:    string(errorType),
			Message: message,
		},
	}
}

// NewValidationError creates a new ValidationError
func NewValidationError(field, message string) *ValidationError {
	return &ValidationError{
		Field:   field,
		Message: fmt.Sprintf("%s: %s", field, message),
	}
}

// NewRateLimitError creates a new RateLimitError from an HTTP response
func NewRateLimitError(resp *http.Response, apiErr *APIError) *RateLimitError {
	retryAfter := 0
	if retryStr := resp.Header.Get("retry-after"); retryStr != "" {
		fmt.Sscanf(retryStr, "%d", &retryAfter)
	}

	requestsLimit := 0
	if limitStr := resp.Header.Get("anthropic-ratelimit-requests-limit"); limitStr != "" {
		fmt.Sscanf(limitStr, "%d", &requestsLimit)
	}

	requestsRemaining := 0
	if remainingStr := resp.Header.Get("anthropic-ratelimit-requests-remaining"); remainingStr != "" {
		fmt.Sscanf(remainingStr, "%d", &requestsRemaining)
	}

	tokensLimit := 0
	if limitStr := resp.Header.Get("anthropic-ratelimit-tokens-limit"); limitStr != "" {
		fmt.Sscanf(limitStr, "%d", &tokensLimit)
	}

	tokensRemaining := 0
	if remainingStr := resp.Header.Get("anthropic-ratelimit-tokens-remaining"); remainingStr != "" {
		fmt.Sscanf(remainingStr, "%d", &tokensRemaining)
	}

	return &RateLimitError{
		APIError:                   apiErr,
		RetryAfter:                 retryAfter,
		RateLimitRequestsLimit:     requestsLimit,
		RateLimitRequestsRemaining: requestsRemaining,
		RateLimitRequestsReset:     resp.Header.Get("anthropic-ratelimit-requests-reset"),
		RateLimitTokensLimit:       tokensLimit,
		RateLimitTokensRemaining:   tokensRemaining,
		RateLimitTokensReset:       resp.Header.Get("anthropic-ratelimit-tokens-reset"),
	}
}

================
File: claude/internal/errors/response.go
================
package errors

import (
	"encoding/json"
	"io"
	"net/http"
)

// ErrorFromResponse creates an APIError from an HTTP response
func ErrorFromResponse(resp *http.Response) *APIError {
	apiErr := &APIError{
		HTTPStatusCode: resp.StatusCode,
		RequestID:      resp.Header.Get("request-id"),
	}

	// Attempt to read and parse the response body
	body, err := io.ReadAll(resp.Body)
	if err == nil && len(body) > 0 {
		if err := json.Unmarshal(body, apiErr); err == nil {
			return apiErr
		}
	}

	// If we couldn't parse the error response, create a generic error
	apiErr.Type = "api_error"
	apiErr.ErrorDetails.Type = http.StatusText(resp.StatusCode)
	apiErr.ErrorDetails.Message = "Request failed with status " + http.StatusText(resp.StatusCode)

	return apiErr
}

================
File: claude/internal/errors/types.go
================
package errors

// ErrorType represents the type of error returned by the Claude API
type ErrorType string

const (
	// ErrorTypeInvalidRequest indicates there was an issue with the format or content of the request
	ErrorTypeInvalidRequest ErrorType = "invalid_request_error"

	// ErrorTypeAuthentication indicates there's an issue with the API key
	ErrorTypeAuthentication ErrorType = "authentication_error"

	// ErrorTypePermission indicates the API key doesn't have permission
	ErrorTypePermission ErrorType = "permission_error"

	// ErrorTypeNotFound indicates the requested resource was not found
	ErrorTypeNotFound ErrorType = "not_found_error"

	// ErrorTypeRequestTooLarge indicates the request exceeds the maximum allowed size
	ErrorTypeRequestTooLarge ErrorType = "request_too_large"

	// ErrorTypeRateLimit indicates the account has hit a rate limit
	ErrorTypeRateLimit ErrorType = "rate_limit_error"

	// ErrorTypeAPI indicates an unexpected error has occurred in Anthropic's systems
	ErrorTypeAPI ErrorType = "api_error"

	// ErrorTypeOverloaded indicates the API is temporarily overloaded
	ErrorTypeOverloaded ErrorType = "overloaded_error"
)

// APIError represents an error returned by the Claude API
type APIError struct {
	Type         string `json:"type"`
	ErrorDetails struct {
		Type    string `json:"type"`
		Message string `json:"message"`
	} `json:"error"`
	HTTPStatusCode int    `json:"-"`
	RequestID      string `json:"-"`
}

// Error implements the error interface
func (e *APIError) Error() string {
	return e.ErrorDetails.Message
}

// ValidationError represents an error in validating request parameters
type ValidationError struct {
	Field   string
	Message string
}

func (e *ValidationError) Error() string {
	return e.Message
}

// RateLimitError represents a rate limit error with additional information
type RateLimitError struct {
	*APIError
	RetryAfter                 int
	RateLimitRequestsLimit     int
	RateLimitRequestsRemaining int
	RateLimitRequestsReset     string
	RateLimitTokensLimit       int
	RateLimitTokensRemaining   int
	RateLimitTokensReset       string
}

================
File: claude/internal/models/models.go
================
package models

import "github.com/omarshaarawi/claude-go/claude/internal/errors"

// Model represents a Claude model identifier
type Model string

const (
	// Claude 3.5 Family
	ModelClaude35Sonnet Model = "claude-3-5-sonnet-20241022" // Latest Sonnet 3.5
	ModelClaude35Haiku  Model = "claude-3-5-haiku-20241022"  // Latest Haiku 3.5

	// Claude 3 Family
	ModelClaude3Opus   Model = "claude-3-opus-20240229"   // Latest Opus
	ModelClaude3Sonnet Model = "claude-3-sonnet-20240229" // Latest Sonnet
	ModelClaude3Haiku  Model = "claude-3-haiku-20240307"  // Latest Haiku

	// Default model to use if none specified
	DefaultModel = ModelClaude35Sonnet
)

// ModelFamily represents the family of Claude models
type ModelFamily string

const (
	ModelFamilyClaude3  ModelFamily = "Claude 3"
	ModelFamilyClaude35 ModelFamily = "Claude 3.5"
)

// ModelConfig contains configuration for a specific model
type ModelConfig struct {
	Name           string
	Family         ModelFamily
	MaxInputTokens int
	DefaultTokens  int // Default value for max_tokens if not specified
	Capabilities   []string
	Description    string
	UseCases       []string
}

// Known capabilities
const (
	CapabilityVision      = "vision"
	CapabilityTools       = "tools"
	CapabilityCompletion  = "completion"
	CapabilityGeneration  = "generation"
	CapabilityAnalysis    = "analysis"
	CapabilityParsing     = "parsing"
	CapabilityCode        = "code"
	CapabilityTranslation = "translation"
)

// ModelConfigs maps Model IDs to their configurations
var ModelConfigs = map[Model]ModelConfig{
	// Claude 3.5 Family
	ModelClaude35Sonnet: {
		Name:           "Claude 3.5 Sonnet",
		Family:         ModelFamilyClaude35,
		MaxInputTokens: 150000,
		DefaultTokens:  4096,
		Capabilities: []string{
			CapabilityVision,
			CapabilityTools,
			CapabilityCompletion,
			CapabilityGeneration,
			CapabilityAnalysis,
			CapabilityParsing,
			CapabilityCode,
			CapabilityTranslation,
		},
		Description: "Most intelligent model, combining top-tier performance with improved speed.",
		UseCases: []string{
			"Advanced research and analysis",
			"Complex problem-solving",
			"Sophisticated language understanding and generation",
			"High-level strategic planning",
			"Code generation",
		},
	},
	ModelClaude35Haiku: {
		Name:           "Claude 3.5 Haiku",
		Family:         ModelFamilyClaude35,
		MaxInputTokens: 100000,
		DefaultTokens:  1024,
		Capabilities: []string{
			CapabilityVision,
			CapabilityTools,
			CapabilityCompletion,
			CapabilityGeneration,
			CapabilityCode,
		},
		Description: "Fastest and most-cost effective model.",
		UseCases: []string{
			"Real-time chatbots",
			"Data extraction and labeling",
			"Content classification",
		},
	},

	// Claude 3 Family
	ModelClaude3Opus: {
		Name:           "Claude 3 Opus",
		Family:         ModelFamilyClaude3,
		MaxInputTokens: 200000,
		DefaultTokens:  4096,
		Capabilities: []string{
			CapabilityVision,
			CapabilityTools,
			CapabilityCompletion,
			CapabilityGeneration,
			CapabilityAnalysis,
			CapabilityParsing,
			CapabilityCode,
			CapabilityTranslation,
		},
		Description: "Strong performance on highly complex tasks, such as math and coding.",
		UseCases: []string{
			"Task automation across APIs and databases",
			"Powerful coding tasks",
			"R&D, brainstorming and hypothesis generation",
			"Drug discovery",
			"Strategy and advanced analysis",
			"Data processing over vast amounts of knowledge",
		},
	},
	ModelClaude3Sonnet: {
		Name:           "Claude 3 Sonnet",
		Family:         ModelFamilyClaude3,
		MaxInputTokens: 150000,
		DefaultTokens:  4096,
		Capabilities: []string{
			CapabilityVision,
			CapabilityTools,
			CapabilityCompletion,
			CapabilityGeneration,
			CapabilityAnalysis,
			CapabilityParsing,
			CapabilityCode,
			CapabilityTranslation,
		},
		Description: "Balances intelligence and speed for high-throughput tasks.",
		UseCases: []string{
			"Sales forecasting",
			"Targeted marketing",
			"Code generation",
			"Quality control",
			"Live support chat",
			"Translations",
		},
	},
	ModelClaude3Haiku: {
		Name:           "Claude 3 Haiku",
		Family:         ModelFamilyClaude3,
		MaxInputTokens: 100000,
		DefaultTokens:  1024,
		Capabilities: []string{
			CapabilityVision,
			CapabilityTools,
			CapabilityCompletion,
			CapabilityGeneration,
			CapabilityCode,
		},
		Description: "Near-instant responsiveness that can mimic human interactions.",
		UseCases: []string{
			"Content moderation",
			"Extracting knowledge from unstructured data",
			"Live support chat",
		},
	},
}

// GetModelsByFamily returns all models belonging to a specific family
func GetModelsByFamily(family ModelFamily) []Model {
	var models []Model
	for model, config := range ModelConfigs {
		if config.Family == family {
			models = append(models, model)
		}
	}
	return models
}

// GetLatestModel returns the latest model of a specific type (opus, sonnet, or haiku)
func GetLatestModel(modelType string) (Model, error) {
	switch modelType {
	case "opus":
		if _, ok := ModelConfigs[ModelClaude3Opus]; ok {
			return ModelClaude3Opus, nil
		}
	case "sonnet":
		if _, ok := ModelConfigs[ModelClaude35Sonnet]; ok {
			return ModelClaude35Sonnet, nil
		}
		if _, ok := ModelConfigs[ModelClaude3Sonnet]; ok {
			return ModelClaude3Sonnet, nil
		}
	case "haiku":
		if _, ok := ModelConfigs[ModelClaude35Haiku]; ok {
			return ModelClaude35Haiku, nil
		}
		if _, ok := ModelConfigs[ModelClaude3Haiku]; ok {
			return ModelClaude3Haiku, nil
		}
	default:
		return "", errors.NewValidationError("modelType", "invalid model type: "+modelType)
	}
	return "", errors.NewValidationError("modelType", "no available model found for type: "+modelType)
}

// ClientConfig adds model-related configuration options
type ClientConfig struct {
	DefaultModel Model // Model to use if none specified
}

// ValidateModel checks if a model is valid and supported
func ValidateModel(model Model) error {
	if model == "" {
		return errors.NewValidationError("model", "model cannot be empty")
	}

	if _, ok := ModelConfigs[model]; !ok {
		return errors.NewValidationError("model", "unsupported model: "+string(model))
	}

	return nil
}

// GetModelConfig returns the configuration for a specific model
func GetModelConfig(model Model) (ModelConfig, error) {
	if config, ok := ModelConfigs[model]; ok {
		return config, nil
	}
	return ModelConfig{}, errors.NewValidationError("model", "unsupported model: "+string(model))
}

// HasCapability checks if a model has a specific capability
func HasCapability(model Model, capability string) bool {
	config, ok := ModelConfigs[model]
	if !ok {
		return false
	}

	for _, cap := range config.Capabilities {
		if cap == capability {
			return true
		}
	}
	return false
}

================
File: claude/internal/ratelimit/limiter.go
================
package ratelimit

import (
	"context"
	"fmt"
	"math"
	"net/http"
	"strconv"
	"sync"
	"time"
)

var defaultRateLimits = map[string]RateLimitConfig{
	// Claude 3.5 Family
	"claude-3-5-sonnet-20241022": {
		RequestsPerMinute: 50,
		TokensPerMinute:   40000,
		TokensPerDay:      1000000,
	},
	"claude-3-5-haiku-20241022": {
		RequestsPerMinute: 50,
		TokensPerMinute:   50000,
		TokensPerDay:      5000000,
	},
	// Claude 3 Family
	"claude-3-opus-20240229": {
		RequestsPerMinute: 50,
		TokensPerMinute:   20000,
		TokensPerDay:      1000000,
	},
	"claude-3-sonnet-20240229": {
		RequestsPerMinute: 50,
		TokensPerMinute:   40000,
		TokensPerDay:      1000000,
	},
	"claude-3-haiku-20240307": {
		RequestsPerMinute: 50,
		TokensPerMinute:   50000,
		TokensPerDay:      5000000,
	},
}

// RateLimitConfig represents the rate limits for a model
type RateLimitConfig struct {
	RequestsPerMinute int
	TokensPerMinute   int
	TokensPerDay      int
}

// TokenBucket implements a thread-safe token bucket algorithm
type TokenBucket struct {
	tokens         float64
	capacity       float64
	rate           float64
	lastRefillTime time.Time
	retryAfter     time.Time
	mu             sync.Mutex
}

// NewTokenBucket creates a new token bucket with initial capacity and refill rate
func NewTokenBucket(capacity int, refillPerSecond float64) *TokenBucket {
	return &TokenBucket{
		tokens:         float64(capacity),
		capacity:       float64(capacity),
		rate:           refillPerSecond,
		lastRefillTime: time.Now(),
	}
}

// Take attempts to take tokens from the bucket, returning wait time if not enough tokens
func (tb *TokenBucket) Take(n int) (time.Duration, bool) {
	tb.mu.Lock()
	defer tb.mu.Unlock()

	now := time.Now()

	if !tb.retryAfter.IsZero() && now.Before(tb.retryAfter) {
		return tb.retryAfter.Sub(now), false
	}

	elapsed := now.Sub(tb.lastRefillTime).Seconds()
	tb.tokens = math.Min(tb.capacity, tb.tokens+elapsed*tb.rate)
	tb.lastRefillTime = now

	if float64(n) > tb.tokens {
		requiredTokens := float64(n) - tb.tokens
		waitTime := time.Duration(requiredTokens / tb.rate * float64(time.Second))
		return waitTime, false
	}

	tb.tokens -= float64(n)
	return 0, true
}

// SetRetryAfter sets a retry-after time based on API response
func (tb *TokenBucket) SetRetryAfter(d time.Duration) {
	tb.mu.Lock()
	defer tb.mu.Unlock()
	tb.retryAfter = time.Now().Add(d)
}

// UpdateCapacity updates the bucket's capacity and current tokens
func (tb *TokenBucket) UpdateCapacity(newCapacity int) {
	tb.mu.Lock()
	defer tb.mu.Unlock()

	ratio := float64(newCapacity) / tb.capacity
	tb.tokens = math.Min(float64(newCapacity), tb.tokens*ratio)
	tb.capacity = float64(newCapacity)
}

// ModelRateLimiter handles rate limiting for a specific model
type ModelRateLimiter struct {
	config            RateLimitConfig
	requestLimiter    *TokenBucket
	tokenMinuteBucket *TokenBucket
	tokenDayBucket    *TokenBucket
	mu                sync.RWMutex
}

// NewModelRateLimiter creates a new model-specific rate limiter
func NewModelRateLimiter(config RateLimitConfig) *ModelRateLimiter {
	return &ModelRateLimiter{
		config:            config,
		requestLimiter:    NewTokenBucket(config.RequestsPerMinute, float64(config.RequestsPerMinute)/60.0),
		tokenMinuteBucket: NewTokenBucket(config.TokensPerMinute, float64(config.TokensPerMinute)/60.0),
		tokenDayBucket:    NewTokenBucket(config.TokensPerDay, float64(config.TokensPerDay)/(24*60*60)),
	}
}

// checkCapacity checks if the request can be made within rate limits
func (ml *ModelRateLimiter) checkCapacity(tokens int) (time.Duration, bool) {
	ml.mu.RLock()
	defer ml.mu.RUnlock()

	if waitTime, ok := ml.requestLimiter.Take(1); !ok {
		return waitTime, false
	}

	if waitTime, ok := ml.tokenMinuteBucket.Take(tokens); !ok {
		return waitTime, false
	}

	if waitTime, ok := ml.tokenDayBucket.Take(tokens); !ok {
		return waitTime, false
	}

	return 0, true
}

// UpdateFromHeaders updates rate limits based on API response headers
func (ml *ModelRateLimiter) UpdateFromHeaders(headers http.Header) {
	ml.mu.Lock()
	defer ml.mu.Unlock()

	if retryAfter := headers.Get("retry-after"); retryAfter != "" {
		if seconds, err := strconv.Atoi(retryAfter); err == nil {
			duration := time.Duration(seconds) * time.Second
			ml.requestLimiter.SetRetryAfter(duration)
			ml.tokenMinuteBucket.SetRetryAfter(duration)
			ml.tokenDayBucket.SetRetryAfter(duration)
		}
	}

	if limit := headers.Get("anthropic-ratelimit-requests-limit"); limit != "" {
		if n, err := strconv.Atoi(limit); err == nil {
			ml.config.RequestsPerMinute = n
			ml.requestLimiter.UpdateCapacity(n)
		}
	}

	if limit := headers.Get("anthropic-ratelimit-tokens-limit"); limit != "" {
		if n, err := strconv.Atoi(limit); err == nil {
			ml.config.TokensPerMinute = n
			ml.tokenMinuteBucket.UpdateCapacity(n)
		}
	}
}

// RateLimiter handles rate limiting across all models
type RateLimiter struct {
	modelLimiters map[string]*ModelRateLimiter
	mu            sync.RWMutex
}

// NewRateLimiter creates a new rate limiter
func NewRateLimiter() *RateLimiter {
	return &RateLimiter{
		modelLimiters: make(map[string]*ModelRateLimiter),
	}
}

// getModelLimiter gets or creates a rate limiter for a specific model
func (rl *RateLimiter) getModelLimiter(model string) (*ModelRateLimiter, error) {
	rl.mu.RLock()
	limiter, ok := rl.modelLimiters[model]
	rl.mu.RUnlock()
	if ok {
		return limiter, nil
	}

	config, ok := defaultRateLimits[model]
	if !ok {
		return nil, fmt.Errorf("unknown model: %s", model)
	}

	rl.mu.Lock()
	defer rl.mu.Unlock()

	// Double-check after acquiring write lock
	if limiter, ok = rl.modelLimiters[model]; ok {
		return limiter, nil
	}

	limiter = NewModelRateLimiter(config)
	rl.modelLimiters[model] = limiter
	return limiter, nil
}

// WaitForCapacity waits until rate limits allow the request
func (rl *RateLimiter) WaitForCapacity(ctx context.Context, model string, totalTokens int) error {
	limiter, err := rl.getModelLimiter(model)
	if err != nil {
		return err
	}

	ticker := time.NewTicker(100 * time.Millisecond)
	defer ticker.Stop()

	attempt := 0
	maxAttempts := 50

	for {
		waitTime, allowed := limiter.checkCapacity(totalTokens)
		if allowed {
			return nil
		}

		attempt++
		if attempt >= maxAttempts {
			return fmt.Errorf("rate limit exceeded: max wait time reached")
		}

		backoffDuration := time.Duration(math.Min(
			float64(waitTime),
			float64(100*time.Millisecond)*math.Pow(1.5, float64(attempt)),
		))

		select {
		case <-ctx.Done():
			return ctx.Err()
		case <-time.After(backoffDuration):
			continue
		}
	}
}

// UpdateLimits updates rate limits based on API response
func (rl *RateLimiter) UpdateLimits(model string, headers http.Header) {
	limiter, err := rl.getModelLimiter(model)
	if err != nil {
		return
	}

	limiter.UpdateFromHeaders(headers)
}

// QueueRequest represents a rate-limited request
type QueueRequest struct {
	Model      string
	TokenCount int
	Context    context.Context
	ResultChan chan<- error
}

// RequestQueue handles queuing and processing of rate-limited requests
type RequestQueue struct {
	requests    chan *QueueRequest
	rateLimiter *RateLimiter
	workerCount int
	shutdown    chan struct{}
}

// NewRequestQueue creates a new request queue
func NewRequestQueue(rateLimiter *RateLimiter, workerCount int) *RequestQueue {
	q := &RequestQueue{
		requests:    make(chan *QueueRequest, 1000),
		rateLimiter: rateLimiter,
		workerCount: workerCount,
		shutdown:    make(chan struct{}),
	}

	for i := 0; i < workerCount; i++ {
		go q.worker()
	}

	return q
}

// SetModelLimits updates or sets the rate limits for a specific model
func (rl *RateLimiter) SetModelLimits(model string, config RateLimitConfig) error {
	if config.RequestsPerMinute <= 0 {
		return fmt.Errorf("requests per minute must be positive")
	}
	if config.TokensPerMinute <= 0 {
		return fmt.Errorf("tokens per minute must be positive")
	}
	if config.TokensPerDay <= 0 {
		return fmt.Errorf("tokens per day must be positive")
	}

	rl.mu.Lock()
	defer rl.mu.Unlock()

	rl.modelLimiters[model] = NewModelRateLimiter(config)
	return nil
}

// GetModelLimits returns the current rate limits for a specific model
func (rl *RateLimiter) GetModelLimits(model string) (*RateLimitConfig, error) {
	rl.mu.RLock()
	defer rl.mu.RUnlock()

	limiter, ok := rl.modelLimiters[model]
	if !ok {
		return nil, fmt.Errorf("no rate limits found for model: %s", model)
	}

	config := limiter.config
	return &config, nil
}

// Submit adds a request to the queue
func (q *RequestQueue) Submit(req *QueueRequest) error {
	select {
	case q.requests <- req:
		return nil
	case <-time.After(5 * time.Second):
		return fmt.Errorf("queue full")
	}
}

// worker processes requests from the queue
func (q *RequestQueue) worker() {
	for {
		select {
		case <-q.shutdown:
			return
		case req := <-q.requests:
			err := q.rateLimiter.WaitForCapacity(req.Context, req.Model, req.TokenCount)
			req.ResultChan <- err
		}
	}
}

// Shutdown stops all workers
func (q *RequestQueue) Shutdown() {
	close(q.shutdown)
}

================
File: claude/internal/transport/retry.go
================
package transport

import (
	"bytes"
	"context"
	"io"
	"math"
	"math/rand"
	"net/http"
	"time"
)

// RetryConfig contains configuration for the retry transport
type RetryConfig struct {
	MaxRetries         int
	RetryWaitMin       time.Duration
	RetryWaitMax       time.Duration
	RetryableHTTPCodes []int
}

// RetryTransport implements automatic retries for failed requests
type RetryTransport struct {
	transport http.RoundTripper
	config    *RetryConfig
}

// NewRetryTransport creates a new retry transport
func NewRetryTransport(transport http.RoundTripper, config *RetryConfig) *RetryTransport {
	return &RetryTransport{
		transport: transport,
		config:    config,
	}
}

// RoundTrip implements the http.RoundTripper interface
func (t *RetryTransport) RoundTrip(req *http.Request) (*http.Response, error) {
	var (
		attempts  = 0
		lastError error
	)

	ctx := req.Context()
	if _, ok := ctx.Deadline(); !ok {
		var cancel context.CancelFunc
		ctx, cancel = context.WithTimeout(ctx, 30*time.Second)
		defer cancel()
	}

	for {
		attempts++

		var body []byte
		if req.Body != nil {
			body, _ = io.ReadAll(req.Body)
			req.Body.Close()
		}

		newReq := req.Clone(ctx)
		if body != nil {
			newReq.Body = io.NopCloser(bytes.NewReader(body))
		}

		resp, err := t.transport.RoundTrip(newReq)
		if err != nil {
			lastError = err
		} else if !t.shouldRetry(resp.StatusCode) {
			return resp, nil
		}

		if attempts >= t.config.MaxRetries {
			if err != nil {
				return nil, lastError
			}
			return resp, nil
		}

		delay := t.calculateDelay(attempts)

		select {
		case <-ctx.Done():
			if err != nil {
				return nil, lastError
			}
			return resp, nil
		case <-time.After(delay):
			continue
		}
	}
}

// shouldRetry checks if a request should be retried based on the status code
func (t *RetryTransport) shouldRetry(statusCode int) bool {
	for _, code := range t.config.RetryableHTTPCodes {
		if statusCode == code {
			return true
		}
	}
	return false
}

// calculateDelay calculates the delay before the next retry attempt
func (t *RetryTransport) calculateDelay(attempt int) time.Duration {
	min := float64(t.config.RetryWaitMin)
	max := float64(t.config.RetryWaitMax)
	base := math.Min(max, min*math.Pow(2, float64(attempt-1)))

	jitter := rand.Float64() * (base * 0.25)
	delay := base + jitter

	if delay > max {
		delay = max
	}

	return time.Duration(delay)
}

================
File: claude/internal/transport/sse.go
================
package transport

import (
	"bufio"
	"bytes"
	"fmt"
	"io"
	"strings"
)

// SSEEvent represents a Server-Sent Event
type SSEEvent struct {
	Event string
	Data  string
	ID    string
}

// SSEDecoder decodes Server-Sent Events from a reader
type SSEDecoder struct {
	reader *bufio.Reader
}

// NewSSEDecoder creates a new SSE decoder
func NewSSEDecoder(r io.Reader) *SSEDecoder {
	return &SSEDecoder{
		reader: bufio.NewReader(r),
	}
}

// Decode reads and decodes the next SSE event
func (d *SSEDecoder) Decode() (*SSEEvent, error) {
	event := &SSEEvent{}
	var buffer bytes.Buffer

	for {
		line, err := d.reader.ReadBytes('\n')
		if err != nil {
			if err == io.EOF {
				if buffer.Len() == 0 {
					return nil, io.EOF
				}
				break
			}
			return nil, fmt.Errorf("error reading SSE line: %w", err)
		}

		line = bytes.TrimSpace(line)
		if len(line) == 0 {
			if buffer.Len() > 0 {
				break
			}
			continue
		}

		parts := bytes.SplitN(line, []byte(":"), 2)
		if len(parts) != 2 {
			continue
		}

		field := string(bytes.TrimSpace(parts[0]))
		value := string(bytes.TrimSpace(parts[1]))

		switch field {
		case "event":
			event.Event = value
		case "data":
			if buffer.Len() > 0 {
				buffer.WriteByte('\n')
			}
			buffer.WriteString(value)
		case "id":
			event.ID = value
		}
	}

	event.Data = strings.TrimSpace(buffer.String())
	return event, nil
}

================
File: claude/client.go
================
package claude

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"log/slog"
	"net/http"
	"net/url"
	"os"
	"runtime"
	"strings"
	"time"

	"github.com/omarshaarawi/claude-go/claude/internal/errors"
	"github.com/omarshaarawi/claude-go/claude/internal/ratelimit"
	"github.com/omarshaarawi/claude-go/claude/internal/transport"
)

const (
	defaultBaseURL = "https://api.anthropic.com"
	defaultTimeout = 30 * time.Second
	apiVersion     = "2023-06-01"
	userAgent      = "claude-go"
)

const (
	BetaPromptCaching  = "prompt-caching-2024-07-31"
	BetaMessageBatches = "message-batches-2024-09-24"
)

// Client is the main struct for interacting with the Claude API
type Client struct {
	// HTTP client for making requests
	httpClient *http.Client

	// Base URL for API requests
	baseURL *url.URL

	// API key used for authentication
	apiKey string

	// Logger instance for debug and error logging
	logger *slog.Logger

	// Custom headers to be sent with each request
	headers map[string]string

	// Message service for interacting with the Messages API
	Messages *MessagesService

	// Message Batches service for interacting with the Message Batches API
	MessageBatches *MessageBatchesService

	// Common options for all requests
	common service

	// Rate limiter
	rateLimiter *ratelimit.RateLimiter

	// Rate limit request queue
	requestQueue *ratelimit.RequestQueue
}

// service is a base service with a reference to the client
type service struct {
	client *Client
}

// ClientOption is a function that modifies the client configuration
type ClientOption func(*Client) error

// NewClientWithConfig creates a new client using the provided configuration
func NewClientWithConfig(config *Config) (*Client, error) {
	if err := config.validate(); err != nil {
		return nil, err
	}

	baseURL, err := url.Parse(config.BaseURL)
	if err != nil {
		return nil, fmt.Errorf("invalid base URL: %w", err)
	}

	httpClient := &http.Client{
		Timeout: config.Timeout,
	}

	// Configure retries
	if config.MaxRetries > 0 {
		httpClient.Transport = transport.NewRetryTransport(
			http.DefaultTransport,
			&transport.RetryConfig{
				MaxRetries:         config.MaxRetries,
				RetryWaitMin:       config.RetryWaitMin,
				RetryWaitMax:       config.RetryWaitMax,
				RetryableHTTPCodes: config.RetryableHTTPCodes,
			},
		)
	}

	c := &Client{
		httpClient: httpClient,
		baseURL:    baseURL,
		apiKey:     config.APIKey,
		logger:     setupLogger(config),
		headers:    make(map[string]string),
	}

	if config.EnableRateLimiting {
		c.rateLimiter = ratelimit.NewRateLimiter()
		c.requestQueue = ratelimit.NewRequestQueue(c.rateLimiter, 5)

		for model, limits := range config.CustomRateLimits {
			if err := c.rateLimiter.SetModelLimits(model, limits); err != nil {
				return nil, fmt.Errorf("error setting rate limits for model %s: %w", model, err)
			}
		}
	}

	if c.headers == nil {
		c.headers = make(map[string]string)
	}

	for _, v := range config.BetaFeatures {
		c.headers["anthropic-beta"] = v
	}

	c.common.client = c
	c.Messages = (*MessagesService)(&c.common)
	c.MessageBatches = (*MessageBatchesService)(&c.common)

	return c, nil
}

// NewClient creates a new Claude API client
func NewClient(apiKey string, opts ...ClientOption) (*Client, error) {
	if apiKey == "" {
		return nil, errors.NewValidationError("apiKey", "API key cannot be empty")
	}

	baseURL, err := url.Parse(defaultBaseURL)
	if err != nil {
		return nil, fmt.Errorf("invalid base URL: %w", err)
	}

	c := &Client{
		httpClient: &http.Client{
			Timeout: defaultTimeout,
		},
		baseURL: baseURL,
		apiKey:  apiKey,
		logger:  slog.Default(),
		headers: make(map[string]string),
	}

	for _, opt := range opts {
		if err := opt(c); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}

	c.common.client = c
	c.rateLimiter = ratelimit.NewRateLimiter()
	c.requestQueue = ratelimit.NewRequestQueue(c.rateLimiter, 5)

	c.Messages = (*MessagesService)(&c.common)
	c.MessageBatches = (*MessageBatchesService)(&c.common)

	return c, nil
}

// WithHTTPClient sets a custom HTTP client
func WithHTTPClient(httpClient *http.Client) ClientOption {
	return func(c *Client) error {
		if httpClient == nil {
			return errors.NewValidationError("httpClient", "HTTP client cannot be nil")
		}
		c.httpClient = httpClient
		return nil
	}
}

// WithBaseURL sets a custom base URL
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		if baseURL == "" {
			return errors.NewValidationError("baseURL", "Base URL cannot be empty")
		}
		parsedURL, err := url.Parse(baseURL)
		if err != nil {
			return fmt.Errorf("invalid base URL: %w", err)
		}
		c.baseURL = parsedURL
		return nil
	}
}

// Add type for beta features
type BetaFeature string

// Add helper to enable beta features
func WithBeta(feature string) ClientOption {
	return func(c *Client) error {
		if c.headers == nil {
			c.headers = make(map[string]string)
		}
		c.headers["anthropic-beta"] = feature
		return nil
	}
}

// Add helper to enable multiple beta features
func WithBetas(features ...string) ClientOption {
	return func(c *Client) error {
		if c.headers == nil {
			c.headers = make(map[string]string)
		}
		c.headers["anthropic-beta"] = strings.Join(features, ",")
		return nil
	}
}

// WithLogger sets a custom logger
func WithLogger(logger *slog.Logger) ClientOption {
	return func(c *Client) error {
		if logger == nil {
			return errors.NewValidationError("logger", "Logger cannot be nil")
		}
		c.logger = logger
		return nil
	}
}

// WithHeader adds a custom header to all requests
func WithHeader(key, value string) ClientOption {
	return func(c *Client) error {
		if key == "" {
			return errors.NewValidationError("key", "Header key cannot be empty")
		}
		c.headers[key] = value
		return nil
	}
}

// Close cleans up any resources used by the client
func (c *Client) Close() {
	if c.requestQueue != nil {
		c.requestQueue.Shutdown()
	}
}

// newRequest creates a new HTTP request
func (c *Client) newRequest(ctx context.Context, method, path string, body interface{}) (*http.Request, error) {
	u := *c.baseURL

	path = "/" + strings.Trim(path, "/")

	u.Path = strings.TrimSuffix(u.Path, "/") + path

	c.logger.Debug("building request",
		"base_url", c.baseURL.String(),
		"path", path,
		"final_url", u.String(),
	)

	var buf io.ReadWriter
	if body != nil {
		buf = new(bytes.Buffer)
		enc := json.NewEncoder(buf)
		enc.SetEscapeHTML(false)
		err := enc.Encode(body)
		if err != nil {
			return nil, fmt.Errorf("error encoding request body: %w", err)
		}
	}

	req, err := http.NewRequestWithContext(ctx, method, u.String(), buf)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("X-API-Key", c.apiKey)
	req.Header.Set("anthropic-version", apiVersion)
	req.Header.Set("User-Agent", fmt.Sprintf("%s/%s (%s/%s)", userAgent, Version, runtime.GOOS, runtime.GOARCH))

	for k, v := range c.headers {
		req.Header.Set(k, v)
	}

	if model, ok := ctx.Value("model").(string); ok {
		req.Header.Set("x-model", model)
	}

	return req, nil
}

// do performs the HTTP request and handles the response
func (c *Client) do(req *http.Request, v interface{}) error {
	if _, ok := c.headers["anthropic-beta"]; ok {
		req.Header.Set("anthropic-beta", c.headers["anthropic-beta"])
	}

	c.logger.Debug("making request",
		"method", req.Method,
		"url", req.URL.String(),
		"path", req.URL.Path,
		"headers", req.Header,
		"request_id", req.Context().Value("request_id"),
	)

	if c.rateLimiter != nil && c.requestQueue != nil {
		model := req.Header.Get("x-model")
		fmt.Printf("\nRate limiting check for model: %s\n", model)

		if model == "" {
			if req.Body != nil {
				bodyBytes, _ := io.ReadAll(req.Body)
				req.Body = io.NopCloser(bytes.NewBuffer(bodyBytes))

				var msgReq struct {
					Model string `json:"model"`
				}
				if err := json.Unmarshal(bodyBytes, &msgReq); err == nil && msgReq.Model != "" {
					model = msgReq.Model
				}
			}
		}

		if model != "" {
			inputTokens := estimateTokenCount(req)
			fmt.Printf("Estimated tokens: %d\n", inputTokens)

			resultChan := make(chan error, 1)

			queueReq := &ratelimit.QueueRequest{
				Model:      model,
				TokenCount: inputTokens,
				Context:    req.Context(),
				ResultChan: resultChan,
			}

			if err := c.requestQueue.Submit(queueReq); err != nil {
				return fmt.Errorf("rate limit queue error: %w", err)
			}

			fmt.Println("Waiting for rate limit clearance...")
			if err := <-resultChan; err != nil {
				return fmt.Errorf("rate limit error: %w", err)
			}
			fmt.Println("✓ Rate limit cleared")
		}
	}

	fmt.Printf("Sending request to %s...\n", req.URL.Path)

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	if c.rateLimiter != nil {
		model := req.Header.Get("x-model")
		if model != "" {
			c.rateLimiter.UpdateLimits(model, resp.Header)
		}
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("failed to read response body: %w", err)
	}

	c.logger.Debug("received response",
		"status_code", resp.StatusCode,
		"body_length", len(body),
		"request_id", resp.Header.Get("request-id"),
	)

	if resp.StatusCode >= 400 {
		var apiErr APIError
		if err := json.Unmarshal(body, &apiErr); err != nil {
			return fmt.Errorf("API error (status %d): %s", resp.StatusCode, string(body))
		}
		if resp.StatusCode == http.StatusTooManyRequests {
			return errors.NewRateLimitError(resp, &apiErr)
		}
		return &apiErr
	}

	if v != nil && len(body) > 0 {
		if msg, ok := v.(*Message); ok {
			var fullResp struct {
				Usage *MessageUsage `json:"usage"`
			}
			if err := json.Unmarshal(body, &fullResp); err == nil && fullResp.Usage != nil {
				msg.Usage = fullResp.Usage
			}
		}

		if err := json.Unmarshal(body, v); err != nil {
			c.logger.Error("failed to decode response",
				"error", err,
				"body", string(body),
			)
			return fmt.Errorf("failed to decode response: %w", err)
		}
	}

	return nil
}

func (c *Client) Version() string {
	return Version
}

func setupLogger(config *Config) *slog.Logger {
	var logHandler slog.Handler

	level := slog.LevelInfo
	switch strings.ToLower(config.LogLevel) {
	case "debug":
		level = slog.LevelDebug
	case "warn":
		level = slog.LevelWarn
	case "error":
		level = slog.LevelError
	}

	var output io.Writer
	switch strings.ToLower(config.LogOutput) {
	case "stderr":
		output = os.Stderr
	case "file":
		if f, err := os.OpenFile("claude.log", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644); err == nil {
			output = f
		} else {
			output = os.Stdout
		}
	default:
		output = os.Stdout
	}

	opts := &slog.HandlerOptions{Level: level}
	switch strings.ToLower(config.LogFormat) {
	case "text":
		logHandler = slog.NewTextHandler(output, opts)
	default:
		logHandler = slog.NewJSONHandler(output, opts)
	}

	return slog.New(logHandler)
}

// Add helper function to estimate token count
func estimateTokenCount(req *http.Request) int {
	if req.Body == nil {
		return 100
	}

	body, err := io.ReadAll(req.Body)
	if err != nil {
		return 100
	}

	req.Body = io.NopCloser(bytes.NewBuffer(body))

	return len(body) / 4
}

================
File: claude/config.go
================
package claude

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"reflect"
	"runtime"
	"strconv"
	"strings"
	"time"

	"github.com/joho/godotenv"
	"github.com/omarshaarawi/claude-go/claude/internal/ratelimit"
)

// ConfigSource represents where a configuration value came from
type ConfigSource string

const (
	// ConfigSourceDefault indicates the value is a default
	ConfigSourceDefault ConfigSource = "default"
	// ConfigSourceEnv indicates the value came from an environment variable
	ConfigSourceEnv ConfigSource = "env"
	// ConfigSourceFile indicates the value came from a config file
	ConfigSourceFile ConfigSource = "file"
)

// Config holds all configuration for the Claude client
type Config struct {
	// API Configuration
	APIKey     string `json:"api_key" env:"CLAUDE_API_KEY"`
	BaseURL    string `json:"base_url" env:"CLAUDE_BASE_URL"`
	APIVersion string `json:"api_version" env:"CLAUDE_API_VERSION"`

	// HTTP Client Configuration
	Timeout            time.Duration `json:"timeout" env:"CLAUDE_TIMEOUT"`
	MaxRetries         int           `json:"max_retries" env:"CLAUDE_MAX_RETRIES"`
	RetryWaitMin       time.Duration `json:"retry_wait_min" env:"CLAUDE_RETRY_WAIT_MIN"`
	RetryWaitMax       time.Duration `json:"retry_wait_max" env:"CLAUDE_RETRY_WAIT_MAX"`
	RetryableHTTPCodes []int         `json:"retryable_http_codes" env:"CLAUDE_RETRYABLE_HTTP_CODES"`

	// Rate Limiting Configuration
	EnableRateLimiting bool                                 `json:"enable_rate_limiting" env:"CLAUDE_ENABLE_RATE_LIMITING"`
	CustomRateLimits   map[string]ratelimit.RateLimitConfig `json:"custom_rate_limits"`

	// Logging Configuration
	LogLevel        string `json:"log_level" env:"CLAUDE_LOG_LEVEL"`
	LogFormat       string `json:"log_format" env:"CLAUDE_LOG_FORMAT"`
	LogOutput       string `json:"log_output" env:"CLAUDE_LOG_OUTPUT"`
	EnableDebugLogs bool   `json:"enable_debug_logs" env:"CLAUDE_ENABLE_DEBUG_LOGS"`

	// Beta Configuration
	BetaFeatures []string `json:"beta_features" env:"CLAUDE_BETA_FEATURES"`

	// Sources tracks where each config value came from
	sources map[string]ConfigSource `json:"-"`
}

// DefaultConfig returns the default configuration
func DefaultConfig() *Config {
	return &Config{
		BaseURL:    defaultBaseURL,
		APIVersion: apiVersion,

		Timeout:            defaultTimeout,
		MaxRetries:         3,
		RetryWaitMin:       1 * time.Second,
		RetryWaitMax:       30 * time.Second,
		RetryableHTTPCodes: []int{408, 429, 500, 502, 503, 504},

		EnableRateLimiting: true,
		CustomRateLimits:   make(map[string]ratelimit.RateLimitConfig),

		LogLevel:  "info",
		LogFormat: "json",
		LogOutput: "stdout",

		sources: make(map[string]ConfigSource),
	}
}

// LoadConfig loads configuration from all available sources
func LoadConfig() (*Config, error) {
	config := DefaultConfig()

	config.markAllFieldsSource(ConfigSourceDefault)

	if err := loadDotEnv(); err != nil {
		return nil, fmt.Errorf("error loading .env file: %w", err)
	}

	if err := config.loadFromEnv(); err != nil {
		return nil, fmt.Errorf("error loading from environment: %w", err)
	}

	if err := config.loadFromFile(); err != nil {
		return nil, fmt.Errorf("error loading from config file: %w", err)
	}

	if err := config.validate(); err != nil {
		return nil, fmt.Errorf("invalid configuration: %w", err)
	}

	return config, nil
}

// loadDotEnv attempts to load the .env file from common locations
func loadDotEnv() error {
	locations := []string{
		".env",
		"../.env",
		os.Getenv("HOME") + "/.config/claude/config.env",
	}

	for _, loc := range locations {
		if _, err := os.Stat(loc); err == nil {
			return godotenv.Load(loc)
		}
	}

	return nil
}

// ConfigFileLocation returns the default config file location for the current OS
func ConfigFileLocation() string {
	switch runtime.GOOS {
	case "windows":
		return filepath.Join(os.Getenv("APPDATA"), "claude", "config.json")
	case "darwin":
		return filepath.Join(os.Getenv("HOME"), "Library", "Application Support", "claude", "config.json")
	default: // linux and others
		if xdgConfig := os.Getenv("XDG_CONFIG_HOME"); xdgConfig != "" {
			return filepath.Join(xdgConfig, "claude", "config.json")
		}
		return filepath.Join(os.Getenv("HOME"), ".config", "claude", "config.json")
	}
}

// loadFromFile loads configuration from the config file
func (c *Config) loadFromFile() error {
	configFile := ConfigFileLocation()
	if _, err := os.Stat(configFile); os.IsNotExist(err) {
		return nil
	}

	data, err := os.ReadFile(configFile)
	if err != nil {
		return fmt.Errorf("error reading config file: %w", err)
	}

	var fileConfig Config
	if err := json.Unmarshal(data, &fileConfig); err != nil {
		return fmt.Errorf("error parsing config file: %w", err)
	}

	c.mergeFrom(&fileConfig, ConfigSourceFile)
	return nil
}

// loadFromEnv loads configuration from environment variables
func (c *Config) loadFromEnv() error {
	return loadEnvVars(c, ConfigSourceEnv)
}

// SaveToFile saves the current configuration to the config file
func (c *Config) SaveToFile() error {
	configFile := ConfigFileLocation()

	if err := os.MkdirAll(filepath.Dir(configFile), 0755); err != nil {
		return fmt.Errorf("error creating config directory: %w", err)
	}

	data, err := json.MarshalIndent(c, "", "  ")
	if err != nil {
		return fmt.Errorf("error marshaling config: %w", err)
	}

	if err := os.WriteFile(configFile, data, 0600); err != nil {
		return fmt.Errorf("error writing config file: %w", err)
	}

	return nil
}

// validate checks if the configuration is valid
func (c *Config) validate() error {
	if c.APIKey == "" {
		return fmt.Errorf("API key is required")
	}

	if c.Timeout < 0 {
		return fmt.Errorf("timeout must be non-negative")
	}

	if c.MaxRetries < 0 {
		return fmt.Errorf("max retries must be non-negative")
	}

	return nil
}

// mergeFrom merges another config into this one, tracking the source
func (c *Config) mergeFrom(other *Config, source ConfigSource) {
	// Use reflection to merge fields and track sources
	mergeConfigs(c, other, source)
}

// markAllFieldsSource marks all fields as coming from the given source
func (c *Config) markAllFieldsSource(source ConfigSource) {
	markFieldsSource(c, source)
}

// GetFieldSource returns the source of a configuration field
func (c *Config) GetFieldSource(field string) ConfigSource {
	if source, ok := c.sources[field]; ok {
		return source
	}
	return ConfigSourceDefault
}

// loadEnvVars loads environment variables into the config struct
func loadEnvVars(config *Config, source ConfigSource) error {
	v := reflect.ValueOf(config).Elem()
	t := v.Type()

	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)
		envTag := field.Tag.Get("env")
		if envTag == "" {
			continue
		}

		envVal := os.Getenv(envTag)
		if envVal == "" {
			continue
		}

		fieldValue := v.Field(i)
		if err := setFieldFromString(fieldValue, envVal); err != nil {
			return fmt.Errorf("error setting %s: %w", field.Name, err)
		}

		config.sources[field.Name] = source
	}

	return nil
}

// setFieldFromString sets a reflect.Value from a string based on its type
func setFieldFromString(v reflect.Value, str string) error {
	switch v.Kind() {
	case reflect.String:
		v.SetString(str)
	case reflect.Bool:
		b, err := strconv.ParseBool(str)
		if err != nil {
			return err
		}
		v.SetBool(b)
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		if v.Type() == reflect.TypeOf(time.Duration(0)) {
			d, err := time.ParseDuration(str)
			if err != nil {
				return err
			}
			v.Set(reflect.ValueOf(d))
		} else {
			i, err := strconv.ParseInt(str, 10, 64)
			if err != nil {
				return err
			}
			v.SetInt(i)
		}
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		i, err := strconv.ParseUint(str, 10, 64)
		if err != nil {
			return err
		}
		v.SetUint(i)
	case reflect.Float32, reflect.Float64:
		f, err := strconv.ParseFloat(str, 64)
		if err != nil {
			return err
		}
		v.SetFloat(f)
	case reflect.Slice:
		if v.Type().Elem().Kind() == reflect.Int {
			parts := strings.Split(str, ",")
			slice := reflect.MakeSlice(v.Type(), len(parts), len(parts))
			for i, part := range parts {
				n, err := strconv.Atoi(strings.TrimSpace(part))
				if err != nil {
					return err
				}
				slice.Index(i).SetInt(int64(n))
			}
			v.Set(slice)
		}
	default:
		return fmt.Errorf("unsupported type: %s", v.Type())
	}
	return nil
}

// mergeConfigs merges two configs using reflection
func mergeConfigs(dest, src *Config, source ConfigSource) {
	vDest := reflect.ValueOf(dest).Elem()
	vSrc := reflect.ValueOf(src).Elem()
	t := vDest.Type()

	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)
		if field.Tag.Get("json") == "-" {
			continue
		}

		destField := vDest.Field(i)
		srcField := vSrc.Field(i)

		if isZeroValue(srcField) {
			continue
		}

		if destField.Kind() == reflect.Map {
			if srcField.Len() > 0 {
				if destField.IsNil() {
					destField.Set(reflect.MakeMap(destField.Type()))
				}
				for _, key := range srcField.MapKeys() {
					destField.SetMapIndex(key, srcField.MapIndex(key))
				}
				dest.sources[field.Name] = source
			}
			continue
		}

		destField.Set(srcField)
		dest.sources[field.Name] = source
	}
}

// markFieldsSource marks all fields as coming from the given source
func markFieldsSource(config *Config, source ConfigSource) {
	v := reflect.ValueOf(config).Elem()
	t := v.Type()

	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)
		if field.Tag.Get("json") == "-" {
			continue
		}
		config.sources[field.Name] = source
	}
}

// isZeroValue checks if a reflect.Value is the zero value for its type
func isZeroValue(v reflect.Value) bool {
	switch v.Kind() {
	case reflect.Array, reflect.Map, reflect.Slice, reflect.String:
		return v.Len() == 0
	case reflect.Bool:
		return !v.Bool()
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		return v.Int() == 0
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		return v.Uint() == 0
	case reflect.Float32, reflect.Float64:
		return v.Float() == 0
	case reflect.Interface, reflect.Ptr:
		return v.IsNil()
	}
	return false
}

================
File: claude/conversation.go
================
package claude

import (
	"context"
	"fmt"

	"github.com/omarshaarawi/claude-go/claude/internal/models"
)

// Conversation represents a conversation with Claude
type Conversation struct {
	client   *Client
	messages []MessageContent
	options  ClientOptions
}

// NewConversation creates a new conversation instance
func (c *Client) NewConversation(opts *ClientOptions) *Conversation {
	options := defaultOptions()
	if opts != nil {
		if opts.Model != "" {
			model, ok := models.ModelConfigs[opts.Model]
			if !ok {
				return nil
			}
			options.Model = opts.Model
			options.MaxTokens = model.DefaultTokens
		}
		if opts.MaxTokens > 0 {
			options.MaxTokens = opts.MaxTokens
		}
		options.System = opts.System
	}

	return &Conversation{
		client:   c,
		messages: make([]MessageContent, 0),
		options:  options,
	}
}

// WithModel sets the model for the conversation
func (conv *Conversation) WithModel(model models.Model) *Conversation {
	conv.options.Model = model
	return conv
}

// WithSystem sets the system prompt for the conversation
func (conv *Conversation) WithSystem(system string) *Conversation {
	conv.options.System = system
	return conv
}

// AddMessage adds a message to the conversation without sending it
func (conv *Conversation) AddMessage(role MessageRole, content string) *Conversation {
	conv.messages = append(conv.messages, MessageContent{
		Role:    role,
		Content: content,
	})
	return conv
}

// WithMaxTokens sets the maximum tokens for the conversation
func (conv *Conversation) WithMaxTokens(maxTokens int) *Conversation {
	conv.options.MaxTokens = maxTokens
	return conv
}

// Send sends the current conversation to Claude and gets a response
func (conv *Conversation) Send(ctx context.Context) (string, error) {
	if err := models.ValidateModel(conv.options.Model); err != nil {
		return "", err
	}

	req := &MessageRequest{
		Model:     string(conv.options.Model),
		MaxTokens: conv.options.MaxTokens,
		System:    conv.options.System,
		Messages:  conv.messages,
	}

	resp, err := conv.client.Messages.Create(ctx, req, &conv.options)
	if err != nil {
		return "", fmt.Errorf("failed to send conversation: %w", err)
	}

	if len(resp.Content) == 0 {
		return "", fmt.Errorf("received empty response")
	}

	conv.messages = append(conv.messages, MessageContent{
		Role: MessageRoleAssistant,
		Content: []ContentBlock{
			{
				Type: ContentBlockTypeText,
				Text: resp.Content[0].Text,
			},
		},
	})

	return resp.Content[0].Text, nil
}

================
File: claude/errors.go
================
package claude

import "github.com/omarshaarawi/claude-go/claude/internal/errors"

// Public error type assertions
type (
	APIError        = errors.APIError
	ValidationError = errors.ValidationError
	RateLimitError  = errors.RateLimitError
)

// Public error checking functions
func IsAPIError(err error) (*APIError, bool) {
	if err == nil {
		return nil, false
	}
	apiErr, ok := err.(*APIError)
	return apiErr, ok
}

// IsValidationError checks if an error is a ValidationError
func IsValidationError(err error) (*ValidationError, bool) {
	if err == nil {
		return nil, false
	}
	valErr, ok := err.(*ValidationError)
	return valErr, ok
}

// IsRateLimitError checks if an error is a RateLimitError
func IsRateLimitError(err error) (*RateLimitError, bool) {
	if err == nil {
		return nil, false
	}
	rateLimitErr, ok := err.(*RateLimitError)
	return rateLimitErr, ok
}

================
File: claude/message_batches.go
================
package claude

import (
	"bufio"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"time"

	"github.com/omarshaarawi/claude-go/claude/internal/errors"
)

// MessageBatchStatus represents the processing status of a message batch
type MessageBatchStatus string

const (
	MessageBatchStatusInProgress MessageBatchStatus = "in_progress"
	MessageBatchStatusCanceling  MessageBatchStatus = "canceling"
	MessageBatchStatusEnded      MessageBatchStatus = "ended"
)

// MessageBatch represents a batch of message requests
type MessageBatch struct {
	ID                string             `json:"id"`
	Type              string             `json:"type"`
	ProcessingStatus  MessageBatchStatus `json:"processing_status"`
	RequestCounts     RequestCounts      `json:"request_counts"`
	EndedAt           *time.Time         `json:"ended_at,omitempty"`
	CreatedAt         time.Time          `json:"created_at"`
	ExpiresAt         time.Time          `json:"expires_at"`
	ArchivedAt        *time.Time         `json:"archived_at,omitempty"`
	CancelInitiatedAt *time.Time         `json:"cancel_initiated_at,omitempty"`
	ResultsURL        string             `json:"results_url"`
}

// RequestCounts represents the counts of requests in different states
type RequestCounts struct {
	Processing int `json:"processing"`
	Succeeded  int `json:"succeeded"`
	Errored    int `json:"errored"`
	Canceled   int `json:"canceled"`
	Expired    int `json:"expired"`
}

// BatchRequest represents a single request in a batch
type BatchRequest struct {
	CustomID string          `json:"custom_id"`
	Params   *MessageRequest `json:"params"`
}

// BatchRequestResult represents the result of a batch request
type BatchRequestResult struct {
	CustomID string      `json:"custom_id"`
	Result   BatchResult `json:"result"`
}

// BatchResult represents the result type and associated data
type BatchResult struct {
	Type    string    `json:"type"` // succeeded, errored, canceled, expired
	Message *Message  `json:"message,omitempty"`
	Error   *APIError `json:"error,omitempty"`
}

// CreateBatchRequest represents a request to create a message batch
type CreateBatchRequest struct {
	Requests []BatchRequest `json:"requests"`
}

// ListBatchesOptions represents options for listing message batches
type ListBatchesOptions struct {
	BeforeID string `url:"before_id,omitempty"`
	AfterID  string `url:"after_id,omitempty"`
	Limit    int    `url:"limit,omitempty"`
}

// ListBatchesResponse represents the response from listing message batches
type ListBatchesResponse struct {
	Data    []MessageBatch `json:"data"`
	HasMore bool           `json:"has_more"`
	FirstID string         `json:"first_id"`
	LastID  string         `json:"last_id"`
}

// MessageBatchesService handles communication with the Message Batches API
type MessageBatchesService service

// Create creates a new message batch
func (s *MessageBatchesService) Create(ctx context.Context, req *CreateBatchRequest) (*MessageBatch, error) {
	if err := validateCreateBatchRequest(req); err != nil {
		return nil, err
	}

	httpReq, err := s.client.newRequest(ctx, http.MethodPost, "/messages/batches", req)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	var batch MessageBatch
	if err := s.client.do(httpReq, &batch); err != nil {
		return nil, err
	}

	return &batch, nil
}

// Get retrieves a message batch by ID
func (s *MessageBatchesService) Get(ctx context.Context, batchID string) (*MessageBatch, error) {
	if batchID == "" {
		return nil, errors.NewValidationError("batchID", "cannot be empty")
	}

	path := fmt.Sprintf("/messages/batches/%s", batchID)
	httpReq, err := s.client.newRequest(ctx, http.MethodGet, path, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	var batch MessageBatch
	if err := s.client.do(httpReq, &batch); err != nil {
		return nil, err
	}

	return &batch, nil
}

// List lists all message batches
func (s *MessageBatchesService) List(ctx context.Context, opts *ListBatchesOptions) (*ListBatchesResponse, error) {
	query := make(map[string]string)
	if opts != nil {
		if opts.BeforeID != "" {
			query["before_id"] = opts.BeforeID
		}
		if opts.AfterID != "" {
			query["after_id"] = opts.AfterID
		}
		if opts.Limit > 0 {
			query["limit"] = fmt.Sprintf("%d", opts.Limit)
		}
	}

	httpReq, err := s.client.newRequest(ctx, http.MethodGet, "/messages/batches", nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	q := httpReq.URL.Query()
	for k, v := range query {
		q.Add(k, v)
	}
	httpReq.URL.RawQuery = q.Encode()

	var response ListBatchesResponse
	if err := s.client.do(httpReq, &response); err != nil {
		return nil, err
	}

	return &response, nil
}

// Cancel cancels a message batch
func (s *MessageBatchesService) Cancel(ctx context.Context, batchID string) (*MessageBatch, error) {
	if batchID == "" {
		return nil, errors.NewValidationError("batchID", "cannot be empty")
	}

	path := fmt.Sprintf("/messages/batches/%s/cancel", batchID)
	httpReq, err := s.client.newRequest(ctx, http.MethodPost, path, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	var batch MessageBatch
	if err := s.client.do(httpReq, &batch); err != nil {
		return nil, err
	}

	return &batch, nil
}

// GetResults retrieves the results of a message batch
func (s *MessageBatchesService) GetResults(ctx context.Context, batchID string) (<-chan BatchRequestResult, <-chan error, error) {
	if batchID == "" {
		return nil, nil, errors.NewValidationError("batchID", "cannot be empty")
	}

	path := fmt.Sprintf("/messages/batches/%s/results", batchID)
	httpReq, err := s.client.newRequest(ctx, http.MethodGet, path, nil)
	if err != nil {
		return nil, nil, fmt.Errorf("error creating request: %w", err)
	}

	resp, err := s.client.httpClient.Do(httpReq)
	if err != nil {
		return nil, nil, fmt.Errorf("error sending request: %w", err)
	}

	// Check for errors
	if resp.StatusCode >= 400 {
		defer resp.Body.Close()
		apiErr := errors.ErrorFromResponse(resp)
		if resp.StatusCode == http.StatusTooManyRequests {
			return nil, nil, errors.NewRateLimitError(resp, apiErr)
		}
		return nil, nil, apiErr
	}

	resultChan := make(chan BatchRequestResult)
	errChan := make(chan error, 1)

	go func() {
		defer resp.Body.Close()
		defer close(resultChan)
		defer close(errChan)

		reader := bufio.NewReader(resp.Body)

		for {
			select {
			case <-ctx.Done():
				errChan <- ctx.Err()
				return
			default:
				// Read line
				line, err := reader.ReadBytes('\n')
				if err != nil {
					if err == io.EOF {
						return
					}
					errChan <- fmt.Errorf("error reading results: %w", err)
					return
				}

				// Parse JSON
				var result BatchRequestResult
				if err := json.Unmarshal(line, &result); err != nil {
					errChan <- fmt.Errorf("error parsing result: %w", err)
					return
				}

				resultChan <- result
			}
		}
	}()

	return resultChan, errChan, nil
}

func validateCreateBatchRequest(req *CreateBatchRequest) error {
	if req == nil {
		return errors.NewValidationError("request", "cannot be nil")
	}

	if len(req.Requests) == 0 {
		return errors.NewValidationError("requests", "cannot be empty")
	}

	if len(req.Requests) > 10000 {
		return errors.NewValidationError("requests", "cannot contain more than 10,000 requests")
	}

	for i, batchReq := range req.Requests {
		if batchReq.CustomID == "" {
			return errors.NewValidationError(fmt.Sprintf("requests[%d].custom_id", i), "cannot be empty")
		}

		if err := validateMessageRequest(batchReq.Params); err != nil {
			return fmt.Errorf("invalid request at index %d: %w", i, err)
		}
	}

	return nil
}

type BatchPoller struct {
	client       *Client
	pollInterval time.Duration
	timeout      time.Duration
	progressFunc func(RequestCounts)
}

func NewBatchPoller(client *Client, opts ...BatchPollerOption) *BatchPoller {
	poller := &BatchPoller{
		client:       client,
		pollInterval: 5 * time.Second,
		timeout:      10 * time.Minute,
		progressFunc: func(RequestCounts) {},
	}

	for _, opt := range opts {
		opt(poller)
	}

	return poller
}

type BatchPollerOption func(*BatchPoller)

func WithPollInterval(d time.Duration) BatchPollerOption {
	return func(p *BatchPoller) {
		p.pollInterval = d
	}
}

func WithTimeout(d time.Duration) BatchPollerOption {
	return func(p *BatchPoller) {
		p.timeout = d
	}
}

func WithProgressCallback(f func(RequestCounts)) BatchPollerOption {
	return func(p *BatchPoller) {
		p.progressFunc = f
	}
}

func (p *BatchPoller) WaitForCompletion(ctx context.Context, batchID string) error {
	ctx, cancel := context.WithTimeout(ctx, p.timeout)
	defer cancel()

	ticker := time.NewTicker(p.pollInterval)
	defer ticker.Stop()

	for {
		select {
		case <-ctx.Done():
			return ctx.Err()
		case <-ticker.C:
			batch, err := p.client.MessageBatches.Get(ctx, batchID)
			if err != nil {
				return fmt.Errorf("error checking batch status: %w", err)
			}

			// Report progress
			p.progressFunc(batch.RequestCounts)

			switch batch.ProcessingStatus {
			case "ended":
				return nil
			case "canceling":
				return fmt.Errorf("batch was cancelled")
			}
		}
	}
}

================
File: claude/messages.go
================
package claude

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"

	"github.com/omarshaarawi/claude-go/claude/internal/errors"
	"github.com/omarshaarawi/claude-go/claude/internal/transport"
)

// Message represents a message in the Claude API
type Message struct {
	ID           string         `json:"id"`
	Type         string         `json:"type"`
	Role         string         `json:"role"`
	Content      []ContentBlock `json:"content"`
	Model        string         `json:"model"`
	StopReason   *string        `json:"stop_reason,omitempty"`
	StopSequence *string        `json:"stop_sequence,omitempty"`
	Usage        *MessageUsage  `json:"usage,omitempty"`
}

// MessageUsage represents the token usage for a message
type MessageUsage struct {
	InputTokens  int `json:"input_tokens"`
	OutputTokens int `json:"output_tokens"`
}

// ContentBlockType represents the type of content in a message
type ContentBlockType string

const (
	ContentBlockTypeText    ContentBlockType = "text"
	ContentBlockTypeImage   ContentBlockType = "image"
	ContentBlockTypeToolUse ContentBlockType = "tool_use"
)

// ContentBlock represents a block of content in a message
type ContentBlock struct {
	Type    ContentBlockType `json:"type"`
	Text    string           `json:"text,omitempty"`
	Image   *ImageContent    `json:"image,omitempty"`
	ToolUse *ToolUse         `json:"tool_use,omitempty"`
}

// ImageContent represents an image in a message
type ImageContent struct {
	Source ImageSource `json:"source"`
}

// ImageSource represents the source of an image
type ImageSource struct {
	Type      string `json:"type"`
	MediaType string `json:"media_type"`
	Data      string `json:"data"`
}

// ToolUse represents a tool use in a message
type ToolUse struct {
	ID    string      `json:"id"`
	Name  string      `json:"name"`
	Input interface{} `json:"input"`
}

// MessageRole represents the role of a message sender
type MessageRole string

const (
	MessageRoleUser      MessageRole = "user"
	MessageRoleAssistant MessageRole = "assistant"
)

// MessageRequest represents a request to create a message
type MessageRequest struct {
	Model      string           `json:"model"`
	MaxTokens  int              `json:"max_tokens,omitempty"`
	Messages   []MessageContent `json:"messages"`
	System     string           `json:"system,omitempty"`
	Stream     bool             `json:"stream,omitempty"`
	Tools      []Tool           `json:"tools,omitempty"`
	ToolChoice *ToolChoice      `json:"tool_choice,omitempty"`
}

type MessageContent struct {
	Role    MessageRole `json:"role"`
	Content interface{} `json:"content"`
}

// Tool represents a tool that can be used by Claude
type Tool struct {
	Name        string          `json:"name"`
	Description string          `json:"description"`
	InputSchema ToolInputSchema `json:"input_schema"`
}

// ToolInputSchema represents the schema for tool input
type ToolInputSchema struct {
	Type       string                             `json:"type"`
	Properties map[string]ToolInputSchemaProperty `json:"properties"`
	Required   []string                           `json:"required,omitempty"`
}

// ToolInputSchemaProperty represents a property in a tool input schema
type ToolInputSchemaProperty struct {
	Type        string `json:"type"`
	Description string `json:"description,omitempty"`
}

// ToolChoice represents the choice of tools for Claude to use
type ToolChoice struct {
	Type string `json:"type"` // "none" or "any"
}

// StreamEvent represents a streaming event
type StreamEvent struct {
	Type    string   `json:"type"`
	Message *Message `json:"message,omitempty"`
	Delta   *Delta   `json:"delta,omitempty"`
	Index   *int     `json:"index,omitempty"`
}

// Delta represents a text delta in a stream
type Delta struct {
	Type        string `json:"type"`
	Text        string `json:"text,omitempty"`
	PartialJSON string `json:"partial_json,omitempty"`
}

// MessagesService handles communication with the Messages API
type MessagesService service

// Create creates a new message
func (s *MessagesService) Create(ctx context.Context, req *MessageRequest, opts *ClientOptions) (*Message, error) {
	for i, msg := range req.Messages {
		if content, ok := msg.Content.(string); ok {
			req.Messages[i].Content = []ContentBlock{
				{
					Type: ContentBlockTypeText,
					Text: content,
				},
			}
		} else if content, ok := msg.Content.([]ContentBlock); ok {
			req.Messages[i].Content = content
		} else {
			return nil, errors.NewValidationError("content", "must be either string or []ContentBlock")
		}
	}

	if err := validateMessageRequest(req); err != nil {
		return nil, err
	}

	httpReq, err := s.client.newRequest(ctx, http.MethodPost, "/messages", req)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	var message Message
	if err := s.client.do(httpReq, &message); err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}

	return &message, nil
}

// Stream creates a new message and streams the response
func (s *MessagesService) Stream(ctx context.Context, req *MessageRequest) (<-chan StreamEvent, <-chan error, error) {
	req.Stream = true

	for i, msg := range req.Messages {
		if content, ok := msg.Content.(string); ok {
			req.Messages[i].Content = []ContentBlock{
				{
					Type: ContentBlockTypeText,
					Text: content,
				},
			}
		} else if content, ok := msg.Content.([]ContentBlock); ok {
			req.Messages[i].Content = content
		} else {
			return nil, nil, errors.NewValidationError("content", "must be either string or []ContentBlock")
		}
	}

	if err := validateMessageRequest(req); err != nil {
		return nil, nil, err
	}

	httpReq, err := s.client.newRequest(ctx, http.MethodPost, "/messages", req)
	if err != nil {
		return nil, nil, fmt.Errorf("error creating request: %w", err)
	}

	resp, err := s.client.httpClient.Do(httpReq)
	if err != nil {
		return nil, nil, fmt.Errorf("error sending request: %w", err)
	}

	if resp.StatusCode >= 400 {
		defer resp.Body.Close()
		apiErr := errors.ErrorFromResponse(resp)
		if resp.StatusCode == http.StatusTooManyRequests {
			return nil, nil, errors.NewRateLimitError(resp, apiErr)
		}
		return nil, nil, apiErr
	}

	eventChan := make(chan StreamEvent)
	errChan := make(chan error, 1)

	go func() {
		defer resp.Body.Close()
		defer close(eventChan)
		defer close(errChan)

		decoder := transport.NewSSEDecoder(resp.Body)
		for {
			select {
			case <-ctx.Done():
				errChan <- ctx.Err()
				return
			default:
				event, err := decoder.Decode()
				if err != nil {
					if err == io.EOF {
						return
					}
					errChan <- fmt.Errorf("error decoding stream: %w", err)
					return
				}

				var streamEvent StreamEvent
				if err := json.Unmarshal([]byte(event.Data), &streamEvent); err != nil {
					errChan <- fmt.Errorf("error unmarshaling stream event: %w", err)
					return
				}

				eventChan <- streamEvent
			}
		}
	}()

	return eventChan, errChan, nil
}

// validateMessageRequest validates a message request
func validateMessageRequest(req *MessageRequest) error {
	if req == nil {
		return errors.NewValidationError("request", "cannot be nil")
	}

	if req.Model == "" {
		return errors.NewValidationError("model", "cannot be empty")
	}

	if len(req.Messages) == 0 {
		return errors.NewValidationError("messages", "cannot be empty")
	}

	for i, msg := range req.Messages {
		if msg.Role == "" {
			return errors.NewValidationError(fmt.Sprintf("messages[%d].role", i), "cannot be empty")
		}
		if msg.Content == nil {
			return errors.NewValidationError(fmt.Sprintf("messages[%d].content", i), "cannot be nil")
		}
	}

	return nil
}

================
File: claude/models.go
================
package claude

import "github.com/omarshaarawi/claude-go/claude/internal/models"

// Model represents a Claude model identifier
type Model = models.Model

// ModelFamily represents the family of Claude models
type ModelFamily = models.ModelFamily

// ModelConfig contains configuration for a specific model
type ModelConfig = models.ModelConfig

// Public model constants
const (
	// Claude 3.5 Family
	ModelClaude35Sonnet = models.ModelClaude35Sonnet
	ModelClaude35Haiku  = models.ModelClaude35Haiku

	// Claude 3 Family
	ModelClaude3Opus   = models.ModelClaude3Opus
	ModelClaude3Sonnet = models.ModelClaude3Sonnet
	ModelClaude3Haiku  = models.ModelClaude3Haiku

	// Model Families
	ModelFamilyClaude3  = models.ModelFamilyClaude3
	ModelFamilyClaude35 = models.ModelFamilyClaude35

	// Default model
	DefaultModel = models.DefaultModel
)

// GetModelsByFamily returns all models belonging to a specific family
func GetModelsByFamily(family ModelFamily) []Model {
	return models.GetModelsByFamily(family)
}

// GetModelConfig returns the configuration for a specific model
func GetModelConfig(model Model) (ModelConfig, error) {
	return models.GetModelConfig(model)
}

// GetLatestModel returns the latest model of a specific type
func GetLatestModel(modelType string) (Model, error) {
	return models.GetLatestModel(modelType)
}

// ValidateModel checks if a model is valid and supported
func ValidateModel(model Model) error {
	return models.ValidateModel(model)
}

================
File: claude/options.go
================
package claude

import (
	"context"
	"fmt"

	"github.com/omarshaarawi/claude-go/claude/internal/models"
)

// ClientOptions holds configuration options for convenience functions
type ClientOptions struct {
	Model     models.Model
	MaxTokens int
	System    string
}

// defaultOptions returns the default client options
func defaultOptions() ClientOptions {
	return ClientOptions{
		Model:     models.DefaultModel,
		MaxTokens: models.ModelConfigs[models.DefaultModel].DefaultTokens,
	}
}

// SendMessage is a convenience function to send a simple text message and get a text response
func (c *Client) SendMessage(ctx context.Context, message string, opts *ClientOptions) (string, error) {
	options := defaultOptions()
	if opts != nil {
		if opts.Model != "" {
			model, ok := models.ModelConfigs[opts.Model]
			if !ok {
				return "", fmt.Errorf("invalid model: %s", opts.Model)
			}
			options.Model = opts.Model
			options.MaxTokens = model.DefaultTokens
		}
		if opts.MaxTokens > 0 {
			options.MaxTokens = opts.MaxTokens
		}
		options.System = opts.System
	}

	if err := models.ValidateModel(options.Model); err != nil {
		return "", err
	}

	req := &MessageRequest{
		Model:     string(options.Model),
		MaxTokens: options.MaxTokens,
		System:    options.System,
		Messages: []MessageContent{
			{
				Role:    MessageRoleUser,
				Content: message,
			},
		},
	}

	resp, err := c.Messages.Create(ctx, req, opts)
	if err != nil {
		return "", fmt.Errorf("failed to send message: %w", err)
	}

	if len(resp.Content) == 0 {
		return "", fmt.Errorf("received empty response")
	}

	return resp.Content[0].Text, nil
}

// SendMessageStream is a convenience function to stream a simple text message
func (c *Client) SendMessageStream(ctx context.Context, message string, opts *ClientOptions) (<-chan string, <-chan error, error) {
	options := defaultOptions()
	if opts != nil {
		if opts.Model != "" {
			model, ok := models.ModelConfigs[opts.Model]
			if !ok {
				return nil, nil, fmt.Errorf("invalid model: %s", opts.Model)
			}
			options.Model = opts.Model
			options.MaxTokens = model.DefaultTokens
		}
		if opts.MaxTokens > 0 {
			options.MaxTokens = opts.MaxTokens
		}
		options.System = opts.System
	}

	if err := models.ValidateModel(options.Model); err != nil {
		return nil, nil, err
	}

	req := &MessageRequest{
		Model:     string(options.Model),
		MaxTokens: options.MaxTokens,
		System:    options.System,
		Messages: []MessageContent{
			{
				Role:    MessageRoleUser,
				Content: message,
			},
		},
		Stream: true,
	}

	events, errChan, err := c.Messages.Stream(ctx, req)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to start stream: %w", err)
	}

	textChan := make(chan string)
	streamErrChan := make(chan error, 1)

	go func() {
		defer close(textChan)
		defer close(streamErrChan)

		for {
			select {
			case event, ok := <-events:
				if !ok {
					return
				}
				if event.Delta != nil && event.Delta.Text != "" {
					textChan <- event.Delta.Text
				}
			case err := <-errChan:
				if err != nil {
					streamErrChan <- err
				}
				return
			case <-ctx.Done():
				streamErrChan <- ctx.Err()
				return
			}
		}
	}()

	return textChan, streamErrChan, nil
}

================
File: claude/version.go
================
package claude

const Version = "0.1.0"

================
File: examples/main.go
================
package main

import (
	"context"
	"fmt"
	"log"
	"os"
	"sync"
	"time"

	"github.com/omarshaarawi/claude-go/claude"
)

func main() {
	// Load configuration, falling back to environment if no config file
	config := &claude.Config{
		APIKey:             os.Getenv("CLAUDE_API_KEY"),
		BaseURL:            "https://api.anthropic.com/v1/",
		LogLevel:           "info",
		EnableRateLimiting: true,
		MaxRetries:         3,
		RetryWaitMin:       1 * time.Second,
		RetryWaitMax:       5 * time.Second,
		Timeout:            30 * time.Second,
		BetaFeatures:       []string{claude.BetaPromptCaching, claude.BetaMessageBatches},
	}

	if config.APIKey == "" {
		log.Fatal("CLAUDE_API_KEY environment variable is required")
	}

	// Create client
	client, err := claude.NewClientWithConfig(config)
	if err != nil {
		log.Fatalf("Error creating client: %v", err)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	// Example 1: Simple Text Message with different models
	fmt.Println("\n=== Example 1: Simple Text Messages with Different Models ===")
	if err := simpleMessages(ctx, client); err != nil {
		log.Printf("Error in simple messages example: %v", err)
	}

	time.Sleep(1 * time.Second)

	// Example 2: Multi-turn Conversation using the Conversation utility
	fmt.Println("\n=== Example 2: Multi-turn Conversation ===")
	if err := improvedConversation(ctx, client); err != nil {
		log.Printf("Error in conversation example: %v", err)
	}

	time.Sleep(1 * time.Second)

	// Example 3: Streaming Response with system prompt
	fmt.Println("\n=== Example 3: Streaming Response with System Prompt ===")
	if err := improvedStreamingMessage(ctx, client); err != nil {
		log.Printf("Error in streaming example: %v", err)
	}

	// Example 4: Model Information
	fmt.Println("\n=== Example 4: Model Information ===")
	printModelInfo()

	// Example 5: Rate Limiting
	if err := rateLimitingExample(ctx, client); err != nil {
		log.Printf("Error in rate limiting example: %v", err)
	}
}

func simpleMessages(ctx context.Context, client *claude.Client) error {
	// Try different models with the same prompt
	models := []claude.Model{
		claude.ModelClaude3Haiku,   // Fastest
		claude.ModelClaude35Sonnet, // Default
		claude.ModelClaude3Opus,    // Most capable
	}

	prompt := "What is the capital of France? Please answer in one sentence."

	for _, model := range models {
		fmt.Printf("\nTrying model: %s\n", model)
		config, _ := claude.GetModelConfig(model)
		fmt.Printf("Model description: %s\n", config.Description)

		response, err := client.SendMessage(ctx, prompt, &claude.ClientOptions{
			Model:     model,
			MaxTokens: config.DefaultTokens,
		})

		if err != nil {
			fmt.Printf("Error with %s: %v\n", model, err)
			continue
		}

		fmt.Printf("Response: %s\n", response)
	}

	return nil
}

func improvedConversation(ctx context.Context, client *claude.Client) error {
	// Create a new conversation with specific options
	conv := client.NewConversation(&claude.ClientOptions{
		Model:  claude.ModelClaude35Sonnet,
		System: "You are a friendly art teacher explaining color theory.",
	})

	// First question
	conv.AddMessage(claude.MessageRoleUser, "What are the three primary colors?")
	response, err := conv.Send(ctx)
	if err != nil {
		return fmt.Errorf("failed to get first response: %w", err)
	}
	fmt.Printf("Assistant: %s\n\n", response)

	// Follow-up question
	conv.AddMessage(claude.MessageRoleUser, "What colors do you get when you mix them?")
	response, err = conv.Send(ctx)
	if err != nil {
		return fmt.Errorf("failed to get second response: %w", err)
	}
	fmt.Printf("Assistant: %s\n", response)

	return nil
}

func improvedStreamingMessage(ctx context.Context, client *claude.Client) error {
	textChan, errChan, err := client.SendMessageStream(ctx,
		"Write a short poem about coding.",
		&claude.ClientOptions{
			Model:  claude.ModelClaude3Haiku, // Using Haiku for faster responses
			System: "You are a poet who writes clever, technical poetry.",
		})

	if err != nil {
		return fmt.Errorf("failed to start stream: %w", err)
	}

	fmt.Print("Assistant: ")
	for {
		select {
		case text, ok := <-textChan:
			if !ok {
				fmt.Println("\nStream completed")
				return nil
			}
			fmt.Print(text)
		case err := <-errChan:
			if err != nil {
				return fmt.Errorf("stream error: %w", err)
			}
			return nil
		case <-ctx.Done():
			return ctx.Err()
		}
	}
}

func rateLimitingExample(ctx context.Context, client *claude.Client) error {
	fmt.Println("\n=== Example 5: Rate Limiting ===")

	// Create a slice of prompts to demonstrate concurrent requests
	prompts := []string{
		"What is 2+2?",
		"What is the capital of France?",
		"Who wrote Romeo and Juliet?",
		"What is the speed of light?",
		"What is photosynthesis?",
		"Name three primary colors.",
		"What is the largest planet?",
		"Who painted the Mona Lisa?",
		"What is the chemical formula for water?",
		"What is the tallest mountain?",
	}

	// Create error group for concurrent requests
	var wg sync.WaitGroup
	results := make(map[int]string)
	errors := make(map[int]error)
	var mu sync.Mutex

	// Process requests concurrently
	fmt.Println("Sending multiple requests concurrently (rate limits will be applied)...")
	for i, prompt := range prompts {
		wg.Add(1)
		go func(index int, question string) {
			defer wg.Done()

			// Create a context with the model information
			ctxWithModel := context.WithValue(ctx, "model", string(claude.ModelClaude35Sonnet))

			// Send the request
			response, err := client.SendMessage(ctxWithModel, question, &claude.ClientOptions{
				Model: claude.ModelClaude35Sonnet,
			})

			mu.Lock()
			if err != nil {
				if rateLimitErr, ok := claude.IsRateLimitError(err); ok {
					errors[index] = fmt.Errorf("rate limit hit: retry after %d seconds (requests remaining: %d/%d, tokens remaining: %d/%d)",
						rateLimitErr.RetryAfter,
						rateLimitErr.RateLimitRequestsRemaining,
						rateLimitErr.RateLimitRequestsLimit,
						rateLimitErr.RateLimitTokensRemaining,
						rateLimitErr.RateLimitTokensLimit,
					)
				} else {
					errors[index] = err
				}
			} else {
				results[index] = response
			}
			mu.Unlock()
		}(i, prompt)
	}

	// Wait for all requests to complete
	wg.Wait()

	// Print results
	fmt.Println("\nResults:")
	for i := 0; i < len(prompts); i++ {
		fmt.Printf("\nPrompt %d: %s\n", i+1, prompts[i])
		if err, hasError := errors[i]; hasError {
			fmt.Printf("Error: %v\n", err)
		} else {
			fmt.Printf("Response: %s\n", results[i])
		}
	}

	return nil
}

func printModelInfo() {
	fmt.Println("\nClaude 3.5 Family Models:")
	fmt.Println("------------------------")
	for _, model := range claude.GetModelsByFamily(claude.ModelFamilyClaude35) {
		config, _ := claude.GetModelConfig(model)
		printModelDetails(model, config)
	}

	fmt.Println("\nClaude 3 Family Models:")
	fmt.Println("---------------------")
	for _, model := range claude.GetModelsByFamily(claude.ModelFamilyClaude3) {
		config, _ := claude.GetModelConfig(model)
		printModelDetails(model, config)
	}
}

func printModelDetails(model claude.Model, config claude.ModelConfig) {
	fmt.Printf("\nModel: %s (%s)\n", config.Name, model)
	fmt.Printf("Family: %s\n", config.Family)
	fmt.Printf("Description: %s\n", config.Description)
	fmt.Printf("Max Input Tokens: %d\n", config.MaxInputTokens)
	fmt.Printf("Default Response Tokens: %d\n", config.DefaultTokens)
	fmt.Printf("Capabilities: %v\n", config.Capabilities)
	fmt.Printf("Use Cases:\n")
	for _, useCase := range config.UseCases {
		fmt.Printf("- %s\n", useCase)
	}
}

================
File: .gitignore
================
bin/
*.out
.env
.idea/
.vscode/
vendor/

.DS_Store

================
File: go.mod
================
module github.com/omarshaarawi/claude-go

go 1.23.0

require github.com/joho/godotenv v1.5.1

================
File: go.sum
================
github.com/joho/godotenv v1.5.1 h1:7eLL/+HRGLY0ldzfGMeQkb7vMd0as4CfYvUVzLqw0N0=
github.com/joho/godotenv v1.5.1/go.mod h1:f4LDr5Voq0i2e/R5DDNOoa2zzDfwtkZa6DnEwAbqwq4=

================
File: LICENSE
================
MIT License

Copyright (c) 2024 Your Name

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: README.md
================
# Claude Go Client

A feature-rich Go client library for the Anthropic Claude API. This library provides idiomatic Go bindings for Claude's Messages and Message Batches APIs, with built-in support for streaming, rate limiting, retries, and model management.

## Features

- ✨ Full support for the Claude 3 and 3.5 model families
- 🔄 Built-in retries with exponential backoff
- 🚦 Automatic rate limiting
- 📺 Streaming support with Server-Sent Events
- 🛠 Message batching for high-throughput use cases
- 💬 Conversation management utilities
- ⚙️ Configurable via environment variables or config file
- 📝 Comprehensive logging support

## Installation

```bash
go get github.com/omarshaarawi/claude-go
```

## Quick Start

```go
package main

import (
    "context"
    "fmt"
    "log"

    "github.com/omarshaarawi/claude-go/claude"
)

func main() {
    // Create a client with an API key
    client, err := claude.NewClient("your-api-key")
    if err != nil {
        log.Fatal(err)
    }

    // Simple message
    response, err := client.SendMessage(context.Background(),
        "What is the meaning of life?",
        &claude.ClientOptions{
            Model: claude.ModelClaude35Sonnet,
        },
    )
    if err != nil {
        log.Fatal(err)
    }
    fmt.Println(response)
}
```

## Advanced Usage

### Streaming Responses

```go
textChan, errChan, err := client.SendMessageStream(ctx,
    "Write a story about a robot learning to love.",
    &claude.ClientOptions{
        Model:  claude.ModelClaude3Haiku,
        System: "You are a creative storyteller.",
    },
)
if err != nil {
    log.Fatal(err)
}

for {
    select {
    case text, ok := <-textChan:
        if !ok {
            return
        }
        fmt.Print(text)
    case err := <-errChan:
        if err != nil {
            log.Fatal(err)
        }
        return
    case <-ctx.Done():
        return
    }
}
```

### Managing Conversations

```go
conv := client.NewConversation(&claude.ClientOptions{
    Model:  claude.ModelClaude35Sonnet,
    System: "You are a helpful coding assistant.",
})

// First message
conv.AddMessage(claude.MessageRoleUser, "What is a closure in Go?")
response, err := conv.Send(ctx)
if err != nil {
    log.Fatal(err)
}
fmt.Println("Assistant:", response)

// Follow-up
conv.AddMessage(claude.MessageRoleUser, "Can you show an example?")
response, err = conv.Send(ctx)
if err != nil {
    log.Fatal(err)
}
fmt.Println("Assistant:", response)
```

### Batch Processing

```go
batch := &claude.CreateBatchRequest{
    Requests: []claude.BatchRequest{
        {
            CustomID: "question-1",
            Params: &claude.MessageRequest{
                Model: string(claude.ModelClaude35Sonnet),
                Messages: []claude.MessageContent{
                    {
                        Role:    claude.MessageRoleUser,
                        Content: "What is 2+2?",
                    },
                },
            },
        },
        // Add more requests...
    },
}

result, err := client.MessageBatches.Create(ctx, batch)
if err != nil {
    log.Fatal(err)
}
```

### Advanced Configuration

```go
config := &claude.Config{
    APIKey:  os.Getenv("CLAUDE_API_KEY"),
    BaseURL: "https://api.anthropic.com/v1/",

    // HTTP Client Configuration
    MaxRetries:   3,
    RetryWaitMin: 1 * time.Second,
    RetryWaitMax: 5 * time.Second,

    // Rate Limiting
    EnableRateLimiting: true,

    // Logging
    LogLevel:  "debug",
    LogFormat: "json",
}

client, err := claude.NewClientWithConfig(config)
if err != nil {
    log.Fatal(err)
}
```

## Available Models

The library supports all Claude 3 and 3.5 models:

- `claude.ModelClaude35Sonnet` - Best balance of intelligence and speed
- `claude.ModelClaude35Haiku` - Fastest response times
- `claude.ModelClaude3Opus` - Most capable for complex tasks
- `claude.ModelClaude3Sonnet` - Balanced performance
- `claude.ModelClaude3Haiku` - Fast and efficient

## Error Handling

The library provides typed errors for better error handling:

```go
response, err := client.SendMessage(ctx, "Hello", nil)
if err != nil {
    switch {
    case claude.IsRateLimitError(err):
        // Handle rate limit
    case claude.IsValidationError(err):
        // Handle validation error
    case claude.IsAPIError(err):
        // Handle API error
    default:
        // Handle other errors
    }
}
```

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.
